"""
Code generated by Stately. DO NOT EDIT.

This package contains a Schema specific client and types
for interacting with your Stately Store.
"""

# ruff: noqa: SIM103, A002, PLR0911, RET504, PLR0912, C901, PLR0913, E501, PLR0915
# ruff: noqa: B008 # remove this after refactoring default values

from __future__ import annotations

from enum import Enum
from uuid import UUID

from statelydb import AuthTokenProvider, StatelyItem, StatelyObject, StoreID
from statelydb import Client as SDKClient
from statelydb.lib.api.db.item_pb2 import Item as PBItem
from statelydb.src.keys import key_path
from statelydb.src.types import BaseTypeMapper

from . import schema_pb2


class Client(SDKClient):
    """
    Client is a Schema specific client for interacting with your Stately Store.
    This Client automatically marshals and unmarshals your Schema types into
    the wire format expected by the Stately API.
    """

    def __init__(
        self,
        store_id: StoreID,
        token_provider: AuthTokenProvider | None = None,
        endpoint: str = "https://api.stately.cloud",
    ) -> None:
        """
        Create a new Client.

        :param store_id: The ID of the store to connect to.
            All client operations will be performed on this
            store.
        :type store_id: StoreID

        :param token_provider: An optional token provider function for
            authenticating requests. Defaults to reading `STATELY_CLIENT_ID`
            and `STATELY_CLIENT_SECRET` from the environment.
        :type token_provider: AuthTokenProvider | None

        :param endpoint: The Stately endpoint to connect to.
            Defaults to "https://api.stately.cloud".
        :type endpoint: str

        """
        super().__init__(
            store_id,
            token_provider=token_provider,
            type_mapper=TypeMapper(),
            endpoint=endpoint,
        )


class SignalingMessageType(Enum):
    """Generated SignalingMessageType enum."""

    SignalingMessageType_UNSPECIFIED = 0
    SignalingMessageType_Join = 1
    SignalingMessageType_Leave = 2
    SignalingMessageType_SDP = 3



class Participant(StatelyItem):
    """Generated Participant object."""

    username: str
    room: str
    _joined: int
    session_id: UUID

    def __init__(
        self,
        *,
        username: str,
        room: str,
        session_id: UUID,
    ) -> None:
        """Create a new Participant."""
        self.username = username
        self.room = room
        self._joined = 0
        self.session_id = session_id

    def key_path(self) -> str:
        """
        Returns the key_path of the current
        Participant.
        """
        return key_path(
            "/Room-{room}/Participant-{username}",
            room=self.room,
            username=self.username,
        )

    @property
    def joined(self) -> int:
        """Get the joined readonly field."""
        return self._joined

    @staticmethod
    def item_type() -> str:
        """
        Returns the item type of Participant
        as a string.
        """
        return "Participant"

    def marshal(self) -> PBItem:
        """Marshal a Participant into a PBItem."""
        o = schema_pb2.Participant()
        o.username = self.username
        o.room = self.room
        o.joined = self.joined
        o.session_id = self.session_id.bytes
        return PBItem(
            proto=o.SerializeToString(),
            item_type=self.item_type(),
        )

    def __eq__(self, other: object) -> bool:
        """
        Enables use of the `==` operator to compare
        Participant instances.
        """
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    @staticmethod
    def unmarshal(proto_bytes: bytes) -> Participant:
        """
        Unmarshal schema_pb2.Participant
        bytes into a new Participant.
        """
        pb = schema_pb2.Participant.FromString(proto_bytes)
        o = Participant(
            username=pb.username,
            room=pb.room,
            session_id=UUID(bytes=pb.session_id),
        )
        o._joined = pb.joined  # noqa: SLF001

        return o


class SignalingMessage(StatelyItem):
    """Generated SignalingMessage object."""

    message_id: int
    message_type: SignalingMessageType
    room: str
    _created_at: int
    payload_json: str

    def __init__(
        self,
        *,
        message_id: int,
        message_type: SignalingMessageType,
        room: str,
        payload_json: str,
    ) -> None:
        """Create a new SignalingMessage."""
        self.message_id = message_id
        self.message_type = message_type
        self.room = room
        self._created_at = 0
        self.payload_json = payload_json

    def key_path(self) -> str:
        """
        Returns the key_path of the current
        SignalingMessage.
        """
        return key_path(
            "/Room-{room}/SignalingMessage-{message_id}",
            room=self.room,
            message_id=self.message_id,
        )

    @property
    def created_at(self) -> int:
        """Get the created_at readonly field."""
        return self._created_at

    @staticmethod
    def item_type() -> str:
        """
        Returns the item type of SignalingMessage
        as a string.
        """
        return "SignalingMessage"

    def marshal(self) -> PBItem:
        """Marshal a SignalingMessage into a PBItem."""
        o = schema_pb2.SignalingMessage()
        o.message_id = self.message_id
        o.message_type = self.message_type.value  # type: ignore[reportAttributeAccessIssue] # https://github.com/protocolbuffers/protobuf/issues/9765
        o.room = self.room
        o.created_at = self.created_at
        o.payload_json = self.payload_json
        return PBItem(
            proto=o.SerializeToString(),
            item_type=self.item_type(),
        )

    def __eq__(self, other: object) -> bool:
        """
        Enables use of the `==` operator to compare
        SignalingMessage instances.
        """
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    @staticmethod
    def unmarshal(proto_bytes: bytes) -> SignalingMessage:
        """
        Unmarshal schema_pb2.SignalingMessage
        bytes into a new SignalingMessage.
        """
        pb = schema_pb2.SignalingMessage.FromString(proto_bytes)
        o = SignalingMessage(
            message_id=pb.message_id,
            message_type=SignalingMessageType(pb.message_type),
            room=pb.room,
            payload_json=pb.payload_json,
        )
        o._created_at = pb.created_at  # noqa: SLF001

        return o


class TypeMapper(BaseTypeMapper):
    """
    TypeMapper is a Schema specific type mapper for unmarshalling items from the Stately
    API into the Schema specific types found in this package.
    """

    @staticmethod
    def unmarshal(item: PBItem) -> StatelyItem:
        """Unmarshal a PBItem into a Schema specific type."""
        if item.item_type == "Participant":
            return Participant.unmarshal(item.proto)
        if item.item_type == "SignalingMessage":
            return SignalingMessage.unmarshal(item.proto)

        msg = f"Unknown item type: {item.item_type}"
        raise ValueError(msg)
