<!DOCTYPE html>
<html>
  <head>
    <title>Multi-Peer WebRTC Call</title>
    <style>
      body {
        display: flex;
        align-items: center;
        width: 100%;
        flex-direction: column;
        text-align: center;
      }

      .control-box {
        display: flex;
        flex-direction: row;
        width: 50%;
      }

      .control-box > * {
        margin: 10px;
      }

      button {
        align-self: center;
        padding: 10px;
      }

      .remote-video-box {
        display: flex;
        overflow-x: auto;
        white-space: nowrap;
        height: 50vh;
        width: 100%;
        justify-content: center;
      }

      .remote-video {
        height: 100%;
        flex-shrink: 0;
        padding: 20px;
      }

      .local-video {
        display: none;
        position: absolute;
        height: 100px;
        top: 0;
        left: 0;
        border: 1px solid red;
        box-shadow: 0 0 10px 5px rgba(0, 0, 0, 0.5);
      }

      .video-box {
        width: 100%;
        position: relative;
      }
    </style>
  </head>
  <body>
    <h2>Join a WebRTC Call</h2>
    <div class="control-box">
      <input id="room" placeholder="Room ID" />
      <input id="username" placeholder="Username" />
      <button onclick="startCall()">Join Call</button>
    </div>
    <div class="video-box">
      <video id="localVideo" autoplay muted class="local-video"></video>
      <div id="remoteVideos" class="remote-video-box"></div>
    </div>
    <script>
      const STUN_HOSTS =
        "https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt";

      const peerConnections = new Map(); // Store peer connections
      let localStream;
      let makingOffer = false;
      const iceServers = fetch(STUN_HOSTS)
        .then((resp) => resp.text())
        .then((text) => text.trim().split("\n"));
      let ws = null;

      function resetWebSocket() {
        ws?.close();
        return new Promise((resolve, reject) => {
          ws = new WebSocket("ws://localhost:8765");
          ws.onclose = function () {
            console.log("Disconnected from signaling server");
          };
          ws.onmessage = async function handleWebsocketMessage(event) {
            const data = JSON.parse(event.data);
            const { type, username, room, description, candidate } = data;

            if (
              type === "user_joined" &&
              username !== document.getElementById("username").value
            ) {
              createPeerConnection(username, this);
            } else if (type === "user_left") {
              removeRemoteVideo(username);
            } else if (type === "sdp") {
              handleSignalingMessage(data, this);
            } else {
              console.log("Unknown message type", data);
            }
          };
          ws.onopen = function () {
            console.log("Connected to signaling server");
            resolve();
            setInterval(() => {
              // set a keepalive for the socket
              // todo - set up all other websocket listeners in here once
              // we are guaranteed that the socket is open
              ws.send(JSON.stringify({ type: "ping" }));
            }, 1000);
          };
        });
      }

      async function startCall() {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true,
        });
        videoElement = document.getElementById("localVideo");
        videoElement.srcObject = localStream;
        videoElement.style.display = "block";
        const room = document.getElementById("room").value;
        const username = document.getElementById("username").value;
        await resetWebSocket();
        ws.send(JSON.stringify({ type: "join", room, username }));
      }

      async function createPeerConnection(peerId) {
        console.log(ws);
        console.log("Creating peer connection for ", peerId);

        const config = {
          iceServers: (await iceServers).map((i) => {
            return {
              urls: `stun:${i}`,
            };
          }),
        };

        const peerConnection = new RTCPeerConnection(config);
        peerConnections.set(peerId, peerConnection);

        localStream
          .getTracks()
          .forEach((track) => peerConnection.addTrack(track, localStream));

        peerConnection.onnegotiationneeded = async () => {
          try {
            makingOffer = true;
            await peerConnection.setLocalDescription();
            ws.send(
              JSON.stringify({
                type: "sdp",
                room: document.getElementById("room").value,
                description: peerConnection.localDescription,
                to: peerId,
              })
            );
          } catch (err) {
            console.error(err);
          } finally {
            makingOffer = false;
          }
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            ws.send(
              JSON.stringify({
                type: "sdp",
                room: document.getElementById("room").value,
                candidate: event.candidate,
                to: peerId,
              })
            );
          }
        };

        peerConnection.ontrack = (event) => {
          addRemoteVideo(peerId, event);
        };
        return peerConnection;
      }

      async function handleSignalingMessage(data) {
        console.log("got signaling messasge");
        const { from, description, candidate, polite } = data;

        let peerConnection = peerConnections.get(from);
        if (!peerConnection) {
          peerConnection = await createPeerConnection(from);
        }

        if (description) {
          const offerCollision =
            description.type === "offer" &&
            (makingOffer || peerConnection.signalingState !== "stable");

          ignoreOffer = !polite && offerCollision;

          if (ignoreOffer) {
            console.log("Ignoring offer");
            return;
          }

          await peerConnection.setRemoteDescription(description);
          if (description.type === "offer") {
            await peerConnection.setLocalDescription();
            ws.send(
              JSON.stringify({
                type: "sdp",
                room: document.getElementById("room").value,
                description: peerConnection.localDescription,
                to: from,
              })
            );
          }
        } else if (candidate) {
          await peerConnection.addIceCandidate(candidate);
        }
      }

      function addRemoteVideo(peerId, event) {
        const remoteVideos = document.getElementById("remoteVideos");
        let videoElement = document.getElementById("remoteVideo_" + peerId);
        if (!videoElement) {
          videoElement = document.createElement("video");
          videoElement.id = "remoteVideo_" + peerId;
          videoElement.className = "remote-video";
          videoElement.autoplay = true;
          remoteVideos.appendChild(videoElement);
        }
        const mediaStream = new MediaStream();
        videoElement.srcObject = event.streams[0];
      }

      function removeRemoteVideo(peerId) {
        const videoElement = document.getElementById("remoteVideo_" + peerId);
        if (videoElement) {
          videoElement.parentNode.removeChild(videoElement);
        }
        peerConnections.delete(peerId);
        console.log("Removed remote video for ", peerId);
      }
    </script>
  </body>
</html>
